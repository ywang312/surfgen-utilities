(* ::Package:: *)

(* ::Code::GrayLevel[0]:: *)
(**)


BeginPackage["TrajectoryAnalysis`"];
(*  TrajectoryAnalysis  *)
(*
    Analysis tool of trajectory data files created by surfgen Evaluation subroutines.*)
(*  Package subroutines  *)
(*
	LoadTrajectory
	GetMoleculeInfo
	AnalyzeTrajectories
	PrintTrajectoryProfile
	ExportGeoms
	AnimateTrajectory
	
*)
AnalyzeTrajectories::usage="AnalyzeTrajectories[] collects information from all trajectories in a given directory.";
LoadTrajectory::usage="LoadTrajectory[] reads in a trajectory data file generated by surfgen evaluation subroutines.";
GetMoleculeInfo::usage="GetMoleculeInfo[] returns the number of atoms, list of atom labels, and the number of states.";
ExportColumbusGeometry::usage="ExportColumbusGeometry[] generates proper COLUMBUS geom file for a set of Cartesian Coordinates.";
ExportGeoms::usage="ExportGeoms[traj,dir,list] saves a list of geometries as loopgeoms in to a specific direcotry.";
AnimateTrajectory::usage="AnimateTrajectory[traj] creates animation for the trajectory.";
PrintTrajectoryProfile::usage="PrintTrajectoryProfile[data] Prints out distance, error, energy and derivative coupling profile of a trajectory.";
GenerateDisplacement::usage="GenerateDisplacement[initial,disp,num] generate Cartesian Coordinates of new geometry based on initial geometry and a displacement vector";
MoleculePlot3D::usage="MoleculePlot3D create 3D graphics for given geometries of a molecule.";
CovalentBonds::usage="CovalentBonds creates covalent bond lists for given geometries.";


ElementInfo=
	{
		{"H",LightGray,0.32},
		{"H1",LightGray,0.32},
		{"H2",LightGray,0.32},
		{"H3",LightGray,0.32},
		{"H4",LightGray,0.32},
		{"C",Gray,0.76},
		{"N",Blue,0.71},
		{"O",Red,0.66},
		{"F",Cyan,0.57},
		{"S",LightBrown,1.05},
		{"Cl",Blend[{Yellow,Green},0.3],1.02},
		{"V",Purple,1.54}
	};


(* Options and default values for MoleculePlot3D*)
Options[MoleculePlot3D]=
	Sort[{
		AtomRadiScaling->0.6,
		RadiusShift->0.2,
		InBohrs->True,
		ShowAtomLabel->true,
		ShowAtomNumber->False,
		BondRadius->0.2,
		BondScaling->1.3,
		Opacity->1.0
	}~Join~Options[Graphics3D]];
SetOptions[MoleculePlot3D,Boxed->False];
Options[CovalentBonds]=
	Sort[{
		BondScaling->1.5,
		InBohrs->True
	}];


CovalentBonds[atomLabels_,rawgeom_,OptionsPattern[]]:=Module[
	{natoms,blist,ratm,atomType,radi,geom,rij,ang2bohr},
	ang2bohr=1.889725989;
	natoms=Length[atomLabels];
	ratm=OptionValue[BondScaling];
	If[OptionValue[InBohrs], ratm=ratm*ang2bohr ];
	atomType=Table[Position[ElementInfo,atomLabels[[j]]][[1,1]],{j,natoms}];
	If[Length[Dimensions[rawgeom]]==1,geom=Partition[rawgeom,3],geom=rawgeom];
	radi=ElementInfo[[atomType,3]]*ratm;
	blist={};
	Do[
		rij=Norm[geom[[i]]-geom[[j]]];
		If[rij<radi[[i]]+radi[[j]],AppendTo[blist,{i,j}]]
	,{i,natoms},{j,i+1,natoms}];
	Return[blist]
];


MoleculePlot3D[atomLabels_,rawgeom_,opts:OptionsPattern[]]:=
Module[
	{ratm,rbnd,natoms,atomType,colors,radi,graph,geom,op,opt2,ang2bohr,inbohr,bscaling,bonds},
	ang2bohr=1.889725989;
	ratm=OptionValue[AtomRadiScaling];
	rbnd=OptionValue[BondRadius];
	inbohr=OptionValue[InBohrs];
	bscaling=OptionValue[BondScaling];
	opt2={opts};
	AppendTo[opt2,Boxed->OptionValue[Boxed]];
	If[inbohr,
		ratm=ratm*ang2bohr;
		rbnd=rbnd*ang2bohr;
	];
	op=OptionValue[Opacity];
	natoms=Length[atomLabels];
	atomType=Table[Position[ElementInfo,atomLabels[[j]]][[1,1]],{j,natoms}];
	colors=ElementInfo[[atomType,2]];
	If[Length[Dimensions[rawgeom]]==1,geom=Partition[rawgeom,3],geom=rawgeom];
	radi=ElementInfo[[atomType,3]]*ratm+OptionValue[RadiusShift];
	graph={EdgeForm[],Opacity[op]};
	bonds=CovalentBonds[atomLabels,rawgeom,BondScaling->bscaling,InBohrs->inbohr];
	Do[
		AppendTo[graph,colors[[j]]];
		AppendTo[graph,Sphere[geom[[j]],radi[[j]]]];
	,{j,natoms}];
	Module[{a1,a2,g1,g2,ctr},
		Do[
			a1=bonds[[j,1]];
			g1=geom[[a1]];
			a2=bonds[[j,2]];
			g2=geom[[a2]];
			ctr=(g1*radi[[a2]]+g2*radi[[a1]])/(radi[[a1]]+radi[[a2]]);
			AppendTo[graph,colors[[a1]]];
			AppendTo[graph,Cylinder[{g1,ctr},rbnd]];
			AppendTo[graph,colors[[a2]]];
			AppendTo[graph,Cylinder[{ctr,g2},rbnd]];
		,{j,Length[bonds]}]
	];
	Return[Graphics3D[graph,Lighting->"Neutral",FilterRules[opt2,Options[Graphics3D]]]];
]


Options[PrintTrajectoryProfile]=
	Sort[{
		UseEvaluationCount->False,
		ImageSize->800,
		AspectRatio->0.1,
		TimeRange->{0,Full},
		PointRange->{0,Full},
		DistanceThreshold->0.1,
		DistancePlotRange->{0,0.2},
		TimeShift->0,
		ErrorPlotRange->{-2000,2000},
		TimePlotRange->{0,Full},
		CouplingPlotRange->Full,
		EnergyPlotRange->{0,60000},
		MaxEnergy->Automatic
	}]~Join~Options[ListLinePlot];
Options[AnimateTrajectory]=
	Sort[{
		ExportAnimation->False,
		ViewPoint->{1,2,6},
		TimeRange->{0,Full},
		TimeDelay->0.2,
		ImageSize->800,
		FontSize->16,
		AnimationRate->20,
		CPPlotRange->Automatic,
		EnergyPlotRange->{0,90000},
		DistancePlotRange->{0,0.15},
		TimeShift->0,
		MessageLifetime->25,
		DistanceThreshold->0.1
	}];
Options[AnalyzeTrajectories]=
	Sort[{
		DistanceThreshold->0.1
	}];


    au2fs=0.02418884326505;
	AtomLabels={};
	NAtoms=0;
	NStates=0;
	au2cm1=219474.6313705;
(*  Load trajectory and get atom labels, number of atoms, states etc.*)

LoadTrajectory[trajfile_]:=Module[
	{trajdata,trajinfo},
	trajdata=Import[trajfile];
	trajinfo=trajdata[[1]];
	trajdata=Delete[trajdata,1];
	{NAtoms,NStates}=trajinfo[[1;;2]];
	AtomLabels=StringTrim[trajinfo[[3;;]]];
	setOffsets[];
	Return[trajdata]
];

(* setOffsets configures the offset in trajdata files for each types of data 
   using the number of states and atoms *)
setOffsets[]:={
	Clear[DataOffset];
	DataOffset["Time"]        = 1;
	DataOffset["Geometry"]    = 3;
	DataOffset["Energy"]      = DataOffset["Geometry"]+3*NAtoms;
	DataOffset["Distance"]    = DataOffset["Energy"]  +NStates;
	DataOffset["Neighbor"]    = DataOffset["Distance"]+1;
	DataOffset["Energy Error"]= DataOffset["Neighbor"]+1;
	DataOffset["Current Surface"] = DataOffset["Energy Error"]+NStates;
	DataOffset["Couplings"]   = DataOffset["Current Surface"]+1;
	DataOffset["Dimensionality"]  = DataOffset["Couplings"]+NStates;
};


PrintTrajectoryProfile[data_List,opt:OptionsPattern[]]:=Module[
	{x,curr,start,end,opt2,tstart,tend,shift},
(* Set up options list*)
	opt2=FilterRules[{opt,LabelStyle->OptionValue[LabelStyle],AspectRatio->OptionValue[AspectRatio],ImageSize->OptionValue[ImageSize]},
		Options[ListPlot]];
	shift=OptionValue[TimeShift];
(* Set plot ranges *)
	{start,end}=OptionValue[PointRange];
	If[start<1||start==All||start==Automatic,start=1];
	If[end<0||end==Full||end==All||end==Automatic||end>Length[data],end=Length[data]];
	{tstart,tend}=OptionValue[TimeRange];
	If[tstart<0||tstart==All||tstart==Automatic,tstart=0];
	If[tend<0||tend==Full||tend==All||tend==Automatic||tend>Length[data],tend=data[[end,1]]*au2fs];
	Do[
		If[data[[j,1]]*au2fs<tstart,start=j+1];
		If[data[[j,1]]*au2fs>tend,end=j-1;Break[]],
	{j,start,end}];
(* Set up the abscissa *)
	If[OptionValue[UseEvaluationCount],
		x[i_]:=i;
	,
		x[i_]:=data[[i,1]]*au2fs+shift;
	];
(* other auxiliary funcitons *)
	curr[i_]:=data[[i,DataOffset["Current Surface"]]];

(* Print the minimum maximum distance plot *)
	Print["Minimum Distance to Existing Points\n",
		Show[
		ListLinePlot[Table[{x[j],data[[j,DataOffset["Distance"]]]},{j,start,end}],
			PlotRange->{OptionValue[TimePlotRange],OptionValue[DistancePlotRange]},PlotStyle->PointSize[Small],opt2
		],
		(* Draw the acceptable area *)
		Plot[OptionValue[DistanceThreshold],{y,x[start],x[end]},
			PlotStyle->Directive[Gray,Opacity[0]], Filling->Bottom,
			FillingStyle->Directive[Gray,Opacity[0.1]]]
	]];


(* Print the energy profile plot *)
	Print["Energy Profile\n",
		ListPlot[Table[{x[j],data[[j,DataOffset["Energy"]-1+k]]*au2cm1},{k,NStates},{j,start,end}]
		~Join~{Table[{x[j],data[[j,DataOffset["Energy"]-1+curr[j]]]*au2cm1},{j,start,end}]},
		PlotRange->{OptionValue[TimePlotRange],OptionValue[EnergyPlotRange]},opt2]
	];

(* Print the derivative coupling size plot *)
	Print["Norm of Derivative Couplings\n"
		ListLinePlot[Table[{x[j],data[[j,DataOffset["Couplings"]-1+k]]},{k,NStates},{j,start,end}],
		PlotRange->{OptionValue[TimePlotRange],OptionValue[CouplingPlotRange]},PlotStyle->{Blue,Purple,Red,Green,Orange,Yellow},opt2]
	];
];



GetMoleculeInfo[]:={NAtoms,AtomLabels,NStates};


ExportColumbusGeometry[printdir_,filename_,geometry_List,cormap_List:{1,2,3},createdir_Symbol:False]:=
	Module[{i,j,cstream,colfile,prnttable,chopgeom},
		chopgeom=Chop[geometry];
		If[createdir,CreateDirectory[ToString[printdir]]];
		colfile=printdir<>"/"<>filename;
		cstream=OpenWrite[colfile];
		For[i=1,i<=2,i++,
			WriteString[cstream,StringJoin[
				" ",AtomLabels[[i]],
				"  ",ToString[PaddedForm[ElementData[AtomLabels[[i]],"AtomicNumber"],{3,0}]],
				"  ",ToString[StringForm["``  ``  ``  ``\n",
					PaddedForm[geometry[[(i-1)*3+cormap[[1]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[geometry[[(i-1)*3+cormap[[2]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[geometry[[(i-1)*3+cormap[[3]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[ElementData[AtomLabels[[i]],"AtomicWeight"],{10,8}]]]
			]]
		];
		For[i=3,i<=7,i++,
			WriteString[cstream,StringJoin[
				" ",AtomLabels[[7]],
				"  ",ToString[PaddedForm[ElementData[1,"AtomicNumber"],{3,0}]],
				"  ",ToString[StringForm["``  ``  ``  ``\n",
					PaddedForm[geometry[[(i-1)*3+cormap[[1]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[geometry[[(i-1)*3+cormap[[2]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[geometry[[(i-1)*3+cormap[[3]]]],{10,8},ExponentFunction->(Null&)],
					PaddedForm[ElementData[1,"AtomicWeight"],{10,8}]]]
			]]
		];
		Close[cstream];
		prnttable=Table[geometry[[(i-1)*3+j]],{i,NAtoms},{j,3}];
	Return[prnttable]
];
(*This subroutine is created only for methylamine because different H atom has different atomlabel as H1,H2...*)


ExportGeoms[data_,dir_,ptlist_]:=Module[{cgeom},
	Print["Number of geometries: ",Length[ptlist]];
	Do[
		cgeom=data[[ptlist[[i]],3;;DataOffset["Energy"]-1]];
		ExportColumbusGeometry[dir,"loopgeom."<>ToString[i],cgeom];
		Print["loopgeom."<>ToString[i],
			": closest to pt #",data[[ptlist[[i]],DataOffset["Neighbor"]]],
			" with dist ",data[[ptlist[[i]],DataOffset["Distance"]]]];
		Print[Framed@MoleculePlot3D[AtomLabels,cgeom,ViewPoint->{1,2,6},ImageSize->150]];
	,{i,Length[ptlist]}];
];


AnimateTrajectory[data_,OptionsPattern[]]:=Module[
	{   startT,endT,dt,size,lastt,curr,animation,fsty,hops,lt,
		frames,tframe,dframe,dimframe,iframe,fpath,sframe,fframe,
		dprofile,eprofile,fprofile,epos,fpos,dth,shift,msgstack,msg
	},
	
(* Load options *)
	dt=OptionValue[TimeDelay]; (*time delay between frames*)
	size=OptionValue[ImageSize]/2;
	fpath=OptionValue[ExportAnimation];
	dth=OptionValue[DistanceThreshold];
	shift=OptionValue[TimeShift];
	lt=OptionValue[MessageLifetime];

(*Set time range for plotting*)
	If[Length[OptionValue[TimeRange]]==2,
		{startT,endT}=OptionValue[TimeRange];
		If[endT==Full||endT==Automatic,endT=Infinity];
		endT=Min[endT,Last[data][[1]]]
	,
		startT=0;
		endT=Last[data][[1]];
	];
	

(* other auxiliary funcitons *)
	curr[i_]:=data[[i,DataOffset["Current Surface"]]];

(*Generate list of frames.  First geometry after each critical time is used.*)
	lastt=startT-dt-1;
	frames={};
	tframe={};
	dframe={};
	sframe={};
	fframe={};
	dimframe={};
	msgstack={};
    msg={};
    hops={};
	iframe={};
	dprofile={};
	eprofile=Table[{},{NStates}];
	fprofile=Table[{},{NStates}];
	epos={};
	fpos={};
	Module[{t},Do[
		t=data[[i,1]]*au2fs+shift;
		If[t>endT,Break[]];
		If[t<startT,Continue[]];
		If[t-lastt>dt,
			AppendTo[frames,data[[i,3;;2+3*NAtoms]]];
			AppendTo[tframe,t];
			AppendTo[dframe,data[[i,DataOffset["Distance"]]]];
			AppendTo[iframe,i];
			AppendTo[dimframe,data[[i,DataOffset["Dimensionality"]]]];
			fsty=Automatic;
			If[Length@sframe>0,If[Last[sframe]!=curr[i],
				AppendTo[hops,{t,Darker@{Blue,Red,Yellow}[[curr[i]]]}];
				fsty=Directive[{Blue,Red,Yellow}[[curr[i]]],Thick];
				AppendTo[msgstack,{"Hop "<>ToString[Last@sframe]<>"\[Rule]"<>ToString[curr[i]],t}]
			]];
			Do[
				If[t-msgstack[[x,2]]>lt,msgstack=Delete[msgstack,x]],
				{x,Length[msgstack],1,-1}];
			AppendTo[msg,
				StringJoin@Table[msgstack[[x,1]]<>"("<>
					StringTrim@ToString@PaddedForm[msgstack[[x,2]],{12,2}]<>"fs)\n",{x,Length[msgstack]}]
			];
			AppendTo[fframe,fsty];
			AppendTo[sframe,curr[i]];
(*energy profile*)
			Do[
				AppendTo[eprofile[[j]],{t,data[[i,DataOffset["Energy"]-1+j]]*au2cm1}];
				AppendTo[fprofile[[j]],{t,data[[i,DataOffset["Couplings"]-1+j]]}];
			,{j,NStates}];
			AppendTo[epos,{t,data[[i,DataOffset["Energy"]-1+curr[i]]]*au2cm1}];
			AppendTo[fpos,t];
			AppendTo[dprofile,{t,Last[dframe]}];
			lastt=t;
		];
	,{i,Length[data]}]];
 
(*atom labels and connectivity relations*)
	animation=Table[
		GraphicsGrid[{
			{
				MoleculePlot3D[AtomLabels,frames[[n]],
					ViewPoint->OptionValue[ViewPoint],ImageSize->size],
				Show[
					ListLogPlot[fprofile,PlotRange->OptionValue[CPPlotRange],Frame->True,ImageSize->size,
						LabelStyle->OptionValue[FontSize],FrameLabel->{"Time (fs)","Coupling Strength"},Joined->True,
						GridLines->{Append[hops,{fpos[[n]],Gray}],{}}]
					]
			},{
				Show[
					ListLinePlot[dprofile,PlotRange->OptionValue[DistancePlotRange],Frame->True,ImageSize->size,
						LabelStyle->OptionValue[FontSize],FrameLabel->{"Time (fs)","Distance to \nNearest Data Point"}],
					Plot[dth,{x,startT,endT},PlotStyle->Directive[Gray,Opacity[0]],Filling->Bottom,
						FillingStyle->Directive[Gray,Opacity[0.1]]],
					ListPlot[{dprofile[[n]]},PlotMarkers->{Automatic,Medium}]],
				Show[
					ListLinePlot[eprofile,PlotRange->OptionValue[EnergyPlotRange],Frame->True,ImageSize->size,
						LabelStyle->OptionValue[FontSize],FrameLabel->{"Time (fs)","Energy (\!\(\*SuperscriptBox[\(cm\), \(-1\)]\))"}],
					ListPlot[{epos[[n]]},PlotMarkers->{Automatic,Medium}]]}
			},Epilog->{Inset[
				Style[Row[Map[Framed,{
					"Time: "<>ToString[PaddedForm[tframe[[n]],{7,2}]]<>"fs",
					"Index:"<>ToString@PaddedForm[iframe[[n]],5],
					"Dist:"<>ToString@PaddedForm[dframe[[n]],{10,4}],
					"Surface: "<>ToString[sframe[[n]]]
				}]," "],20,Background->White],{Left,Top},{-1.2,1}],Inset[Style[msg[[n]],30,Opacity[0.5]]]},Frame->All,FrameStyle->fframe[[n]]],{n,1,Length[frames]}];
		Print[ListAnimate[animation,AnimationRate->OptionValue[AnimationRate]]];
		If[StringQ[fpath],Export[fpath,animation,"DefaultDurations"->dt]];
		Return[animation];
	];


GenerateDisplacement[initial_,displacement_,numberofgeometry_]:=
             Module[{initialgeom,dispvector,i,inter},
                    initialgeom=Import[initial,"Table"];
                    dispvector=Import[displacement,"Table"];
                    For[i=1,i<=numberofgeometry,i++,
                        inter=initialgeom+dispvector;
                        ExportColumbusGeometry[NotebookDirectory[],"loopgeom."<>ToString[i],inter];
                        initialgeom=inter;]
];


AnalyzeTrajectories[dir_,ntraj_Integer:1000,OptionsPattern[]]:=Module[
	{fname,minE,maxEE,maxd,nread,data,style1,style2,stylesafe,dthreshold},
	dthreshold=OptionValue[DistanceThreshold];
	Print["Trajectory #\tMinimum Energy\tMax Min-Distance"];
	nread=0;
	Do[
		fname=dir<>"trajdata"<>ToString[itraj]<>".csv";
		If[!FileExistsQ[fname],Continue[]];
		nread=itraj;
		data=LoadTrajectory[fname];
		minE  = Min@data[[;;,DataOffset["Energy"];;DataOffset["Distance"]-1]]*au2cm1;
		maxd  = Max@data[[;;,DataOffset["Distance"]]];
		If[minE<0||maxd>dthreshold,
			style1=If[minE<0,Red,Black];
			style2=If[maxd>dthreshold,Red,Black];
			Print[
				PaddedForm[itraj,6],"       \t",
				Style[DecimalForm[minE],style1],"     \t",
				Style[DecimalForm[maxd],style2]
			];
			];
		If[minE>0||maxd<dthreshold,
			stylesafe=If[minE>0||maxd<dthreshold,Black,Black];
			Print[
				PaddedForm[itraj,6],"           \t",
				Style[DecimalForm[minE,5],stylesafe],"    \t",
				Style[maxd,stylesafe]
				];
		];
	,{itraj,ntraj}];
	Print["The last trajectory profile read is"," ",nread]
];
(*AnalyzeTrajectories[dir_,opt:OptionsPattern[]]:=AnalyzeTrajectories[dir,1000,opt];*)


EndPackage[]
